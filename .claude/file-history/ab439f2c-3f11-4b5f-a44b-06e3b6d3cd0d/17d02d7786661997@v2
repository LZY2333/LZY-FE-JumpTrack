import TagCascader from '@/_blocks/Managements/_components/TagCascader'
import { api } from '@/utils/api'
import { ProTable } from '@ant-design/pro-components'
import {
  CreateVideoType,
  GenerationTemplateOpenType,
  GenerationTemplateStatus,
} from '@loc/prisma'
import { ETemplateSource } from '@loc/server/enums/template.common'
import { EServiceProvider } from '@loc/server/enums/video'
import { EVideoModel } from '@loc/server/enums/video.common'
import { TranslationTarget } from '@loc/server/interface/schema/translation.common'
import { Button, Image, Modal, Radio } from 'antd'
import { omit } from 'lodash-es'

import type { ISelectedTag } from '@/_blocks/Managements/TagManagement/_components/TagSelectionModal/TagSelectionModalContent'
import type { RouterOutputs } from '@/utils/api'
import type { ActionType, ProColumns } from '@ant-design/pro-components'

import { AddCategory } from '../_components/AddCategory'
import { ImportJsonModel } from '../_components/ImportJsonModel'
import { RefreshTrans } from '../_components/RefreshTrans'
import { handleExportJSON } from '../_helpers'
import { sleep } from '../_helpers/sleep'
import AddModal from './AddModal'
import { RelationDrawer } from './RelationDrawer'

import type { IPermissionLayoutProps } from '../_layout'
import type { AccountInfo } from './AddModal/Creator'

export type TTemplateList =
  RouterOutputs['generationTemplate']['pageTemplates']['items']

export default function Usage(props: Pick<IPermissionLayoutProps, 'dark'>) {
  const actionRef = useRef<ActionType>()

  const [serviceProvider, setServiceProvider] = useState<EServiceProvider>()
  const [source, setSource] = useState<ETemplateSource>()
  const [status, setStatus] = useState<GenerationTemplateStatus | undefined>()
  const [page, setPage] = useState(1)
  const [editItem, setEditItem] = useState<TTemplateList[0] | undefined>()
  const [open, setOpen] = useState(false)
  const [templateList, setTemplateList] = useState<TTemplateList | undefined>()
  const [relationOpen, setRelationOpen] = useState(false)
  const [openType, setOpenType] = useState<
    GenerationTemplateOpenType | undefined
  >()

  const [importModelOpen, setImportJsonModelOpen] = useState(false)
  const [videoType, setVideoType] = useState<CreateVideoType>(
    CreateVideoType.Template,
  )
  const [title, setTitle] = useState('')
  const [selectedTags, setSelectedTags] = useState<ISelectedTag[]>([])

  const { refetch } = api.generationTemplate.pageTemplates.useQuery(
    {
      status,
      page,
      serviceProvider,
      pageSize: 1000,
      videoType,
      openType,
      source,
      title,
      tagIds:
        selectedTags.length > 0 ? selectedTags.map((tag) => tag.id) : undefined,
    },
    {
      enabled: false,
    },
  )

  useEffect(() => {
    if (actionRef.current) {
      actionRef.current.reload()
    }
  }, [status, serviceProvider, videoType, openType])

  const { mutateAsync: updateStatus, isLoading: isUpdatingStatus } =
    api.generationTemplate.updateStatus.useMutation()

  const onChangeStatus = async (
    status: GenerationTemplateStatus,
    id: string,
  ) => {
    await Modal.confirm({
      title: 'Are you sure you want to update the status?',
      onOk: async () => {
        await updateStatus({
          id,
          status,
        })
        actionRef.current?.reload()
      },
    })
  }

  const columns: ProColumns<TTemplateList[0]>[] = [
    {
      title: 'Sort',
      dataIndex: 'sort',
      hideInSearch: true,
      renderText(text) {
        return text ?? '--'
      },
    },
    {
      title: 'Title',
      dataIndex: 'title',
      minWidth: 200,
      search: {
        transform: (value) => setTitle(value),
      },
    },
    {
      title: 'Tag(new)',
      dataIndex: 'tagIds',
      hideInTable: true,
      renderFormItem: () => (
        <TagCascader value={selectedTags} onChange={setSelectedTags} />
      ),
    },
    {
      title: 'Video type',
      dataIndex: 'videoType',
      valueEnum: CreateVideoType,
      valueType: 'select',
      search: {
        transform: (value) => setVideoType(value as CreateVideoType),
      },
    },
    {
      title: 'Open Type',
      dataIndex: 'openType',
      valueEnum: GenerationTemplateOpenType,
      hideInTable: true,
      valueType: 'select',
      search: {
        transform: (value) => setOpenType(value as GenerationTemplateOpenType),
      },
    },
    {
      title: 'Service provider',
      dataIndex: 'serviceProvider',
      valueEnum: EServiceProvider,
      valueType: 'select',
      search: {
        transform: (value) =>
          setServiceProvider(
            EServiceProvider[value as keyof typeof EServiceProvider],
          ),
      },
    },
    {
      title: 'Model',
      dataIndex: 'videoModel',
      valueEnum: EVideoModel,
      valueType: 'select',
      hideInSearch: true,
    },
    {
      title: 'Template code',
      dataIndex: 'templateCode',
      hideInSearch: true,
      minWidth: 200,
    },
    // {
    //   title: 'Assets count',
    //   dataIndex: 'assetsNum',
    //   hideInSearch: true,
    // },
    // {
    //   title: 'Assets type',
    //   dataIndex: 'assetsType',
    //   hideInSearch: true,
    // },
    {
      title: 'Image ratio',
      dataIndex: 'aspectRatio',
      hideInSearch: true,
    },
    // s
    // {
    //   title: 'Credits',
    //   dataIndex: 'templateCredit',
    //   hideInSearch: true,
    // },
    // {
    //   title: 'Corner mark',
    //   dataIndex: 'templateMarks',
    //   hideInSearch: true,
    //   renderText(arr) {
    //     return (arr || []).join('、')
    //   },
    // },
    {
      title: 'Status',
      dataIndex: 'status',
      valueEnum: GenerationTemplateStatus,
      renderText(text, record) {
        const isENABLED = text === GenerationTemplateStatus.ENABLED
        const isDISABLED = text === GenerationTemplateStatus.DISABLED
        const isHIDDEN = text === GenerationTemplateStatus.HIDDEN
        return (
          <Radio.Group
            disabled={isUpdatingStatus}
            value={text}
            onChange={(e) => {
              onChangeStatus(e.target.value, record.id)
            }}
          >
            <Radio value={GenerationTemplateStatus.ENABLED}>
              <span className={cls`text-xs ${isENABLED && 'text-f-success'}`}>
                Enabled
              </span>
            </Radio>
            <Radio value={GenerationTemplateStatus.DISABLED}>
              <span className={cls`text-xs ${isDISABLED && 'text-f-error'}`}>
                Disabled
              </span>
            </Radio>
            <Radio value={GenerationTemplateStatus.HIDDEN}>
              <span className={cls`text-xs ${isHIDDEN && 'text-f-error'}`}>
                Hidden
              </span>
            </Radio>
            {/* <Radio value={GenerationTemplateStatus.DELETED}>
              <span className='text-xs'>Deleted</span>
            </Radio> */}
          </Radio.Group>
        )
      },
      search: {
        transform: (value) => setStatus(value),
      },
    },
    {
      title: 'Cover image',
      dataIndex: 'coverImg',
      hideInSearch: true,
      render(text, record) {
        return record.coverImg ? (
          <Image
            src={record.coverImg}
            className='!h-[100px] !w-[200px] object-contain'
          />
        ) : (
          ''
        )
      },
    },
    {
      title: 'Source',
      dataIndex: 'source',
      valueType: 'select',
      valueEnum: ETemplateSource,
      initialValue: ETemplateSource.Official,
      render(text, record) {
        return record.source
      },
      search: {
        transform: (value) =>
          setSource(ETemplateSource[value as keyof typeof ETemplateSource]),
      },
    },
    {
      title: '已关联的分类',
      dataIndex: 'categoryGenerationTemplateIdList',
      key: 'categoryGenerationTemplateIdList',
      hideInSearch: true,
      width: 150,
      render: (_, record) => {
        return (
          <AddCategory
            mode='table'
            value={record.categoryGenerationTemplateIdList}
            templateId={record.id || ''}
          />
        )
      },
    },
    // {
    //   title: 'Video',
    //   dataIndex: 'coverVideo',
    //   hideInSearch: true,
    //   renderText(text, record) {
    //     return (
    //       <div className='h-[100px] w-[200px]'>
    //         {record.coverVideo ? (
    //           <video
    //             src={record.coverVideo}
    //             controls
    //             className='h-[100px] w-[200px]'
    //           />
    //         ) : (
    //           ''
    //         )}
    //       </div>
    //     )
    //   },
    // },
    // {
    //   title: 'Category',
    //   dataIndex: 'templateCategory',
    //   hideInSearch: true,
    // },
    // {
    //   title: 'Enable hover',
    //   dataIndex: 'enableHover',
    //   hideInSearch: true,
    // },
    // {
    //   title: 'Max length',
    //   dataIndex: 'maxLength',
    //   hideInSearch: true,
    // },
    // {
    //   title: 'Comments',
    //   dataIndex: 'comments',
    //   hideInSearch: true,
    // },
    {
      title: 'Option',
      valueType: 'option',
      width: 150,
      fixed: 'right',
      render: (text, record, _, action) => [
        <div key='editable' className='flex flex-col gap-1'>
          <Button
            type='primary'
            onClick={() => {
              setOpen(true)
              setEditItem(record)
            }}
          >
            Edit
          </Button>
          <Button
            type='primary'
            onClick={() => {
              setRelationOpen(true)
              setEditItem(record)
            }}
          >
            Sub Templates
          </Button>
          <Button type='primary'>
            <Link
              href={`/video-effects/${record.templateCode}`}
              target='_blank'
              className='hover:!text-f-text'
            >
              Try Template
            </Link>
          </Button>
          <Button
            type='primary'
            onClick={() => {
              handleExportJSON(
                omit(record, [
                  'id',
                  'createdDate',
                  'updatedDate',
                  'subTemplates',
                  'user',
                  'userId',
                ]),
              )
            }}
          >
            Export Data
          </Button>
        </div>,
      ],
    },
  ]

  const onEditItemChange = (value: AccountInfo) => {
    if (!editItem || !value) return
    const newUser = {} as NonNullable<TTemplateList[0]['user']>
    for (const k in editItem.user) {
      const key = k as keyof TTemplateList[0]['user'] &
        keyof AccountInfo['userInfo']
      newUser[key] = value.userInfo[key] as (typeof newUser)[typeof key]
    }
    setEditItem({
      ...editItem,
      userId: value.userInfo.id,
      user: newUser,
    })
  }

  return (
    <>
      <ProTable<TTemplateList[0]>
        columns={columns}
        actionRef={actionRef}
        cardBordered
        request={async (params) => {
          const { data } = await refetch()
          const list = data || { items: [], total: 0 }
          setTemplateList(list.items)
          return Promise.resolve({
            data: list.items,
            total: list.total,
            success: true,
          })
        }}
        scroll={{
          x: 1200,
          y: 'calc(100vh - 420px)',
        }}
        rowKey='id'
        search={{
          labelWidth: 'auto',
          optionRender: ({ searchText, resetText }, { form }) => [
            <div className='flex gap-x-2' key={'search'}>
              <Button
                type='primary'
                onClick={() => {
                  setTitle('')
                  setServiceProvider(undefined)
                  setVideoType(CreateVideoType.Template)
                  setOpenType(undefined)
                  setStatus(undefined)
                  setSelectedTags([])

                  form?.resetFields()
                }}
              >
                {resetText}
              </Button>
              <Button
                type='primary'
                onClick={async () => {
                  form?.submit()
                }}
              >
                {searchText}
              </Button>
            </div>,
          ],
        }}
        options={{
          setting: {
            listsHeight: 400,
          },
        }}
        pagination={{
          current: page,
          pageSize: 1000,
          onChange: (page) => {
            setPage(page)
            sleep(100)
            actionRef.current?.reload()
          },
        }}
        headerTitle='Config'
        toolBarRender={() => [
          <Button
            className={cls`flex items-center gap-x-1`}
            key='button'
            onClick={() => {
              setOpen(true)
              setEditItem(undefined)
            }}
            type='primary'
          >
            <span>Add</span>
          </Button>,
          <RefreshTrans
            key='refresh'
            target={TranslationTarget.GENERATION_TEMPLATE}
          />,
          <Button
            className={cls`flex items-center gap-x-1`}
            key='import'
            type='primary'
            onClick={() => {
              setImportJsonModelOpen(true)
            }}
          >
            <span>Import JSON</span>
          </Button>,
        ]}
      />
      <AddModal
        editItem={editItem}
        open={open}
        onCancel={(reload) => {
          setOpen(false)
          setEditItem(undefined)
          if (reload) {
            actionRef.current?.reload(true)
          }
        }}
        onEditItemChange={onEditItemChange}
      />
      <RelationDrawer
        onCancel={() => {
          setRelationOpen(false)
          setEditItem(undefined)
        }}
        allTemplates={templateList}
        editItem={editItem}
        open={relationOpen}
        refetch={async () => {
          const { data } = await refetch()
          if (data) {
            setEditItem(data.items[0])
          }
          actionRef.current?.reload(true)
        }}
      />
      <ImportJsonModel
        open={importModelOpen}
        onCancel={() => {
          setImportJsonModelOpen(false)
          setEditItem(undefined)
        }}
        onOk={() => {
          setImportJsonModelOpen(false)
          setOpen(true)
        }}
        onChange={(value) => {
          setEditItem(value)
        }}
      />
    </>
  )
}
